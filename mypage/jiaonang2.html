<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>é«˜æ€»å®šåˆ¶æŠ•å¸æœº</title>
    <style>
        body {
            background-color: #050510;
            color: #fff;
            font-family: 'Arial Black', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 10px;
            min-height: 100vh;
            box-sizing: border-box;
            touch-action: none;
        }
        h2 { margin: 5px 0; color: #00ffff; text-shadow: 0 0 10px #00ffff, 2px 2px #ff00ff; font-size: 24px; letter-spacing: 2px;}
        
        .header-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 400px;
            background: linear-gradient(180deg, #1a1a2e, #16213e);
            padding: 10px 15px;
            border-radius: 10px;
            border: 2px solid #0f3460;
            margin-bottom: 10px;
            box-sizing: border-box;
            box-shadow: 0 4px 15px rgba(0,255,255,0.2);
        }

        .asset-info { font-size: 16px; color: #e94560; }
        #coin-count { color: #00FF00; font-size: 24px; text-shadow: 0 0 8px #00FF00; }
        
        .next-piece-box {
            background: #000;
            border: 2px inset #0f3460;
            border-radius: 5px;
            width: 50px;
            height: 26px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 10px #0f3460;
        }

        .main-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
            width: 100%;
            max-width: 400px;
        }

        /* --- æ¸¸æˆç½‘æ ¼ --- */
        .game-frame {
            background: #111;
            padding: 6px;
            border: 3px solid #0f3460;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(15, 52, 96, 0.8), inset 0 0 20px #000;
        }
        #game-board {
            display: grid;
            grid-template-rows: repeat(16, 22px);
            grid-template-columns: repeat(10, 22px);
            background-color: #050505;
            border: 1px solid #333;
        }
        .cell {
            width: 22px;
            height: 22px;
            box-sizing: border-box;
            border: 1px solid rgba(255,255,255,0.03);
            transition: background-color 0.2s; 
        }
        
        .c1 { background: radial-gradient(circle at 30% 30%, #ff2a2a, #800000); box-shadow: inset -2px -2px 4px rgba(0,0,0,0.6); }
        .c2 { background: radial-gradient(circle at 30% 30%, #ffea00, #808000); box-shadow: inset -2px -2px 4px rgba(0,0,0,0.6); }
        .c3 { background: radial-gradient(circle at 30% 30%, #00e5ff, #005580); box-shadow: inset -2px -2px 4px rgba(0,0,0,0.6); }
        .virus { border-radius: 50%; border: 2px dashed #fff; animation: pulse 0.8s infinite alternate; }
        @keyframes pulse { from { transform: scale(0.85); box-shadow: 0 0 5px currentColor; } to { transform: scale(1.05); box-shadow: 0 0 15px currentColor; } }
        
        .capsule-left { border-radius: 12px 0 0 12px; }
        .capsule-right { border-radius: 0 12px 12px 0; }
        .capsule-top { border-radius: 12px 12px 0 0; }
        .capsule-bottom { border-radius: 0 0 12px 12px; }

        /* --- 3D è¡—æœºæ§åˆ¶æŒ‰é”® --- */
        .touch-controls {
            display: grid;
            grid-template-columns: 1fr 1fr; 
            grid-template-rows: auto auto; 
            gap: 12px;
            width: 100%;
            margin-top: 5px;
        }
        .btn {
            background: linear-gradient(to bottom, #1a1a2e, #0f3460);
            border: 1px solid #00ffff;
            color: #00ffff;
            font-size: 22px;
            padding: 15px 0;
            border-radius: 12px;
            cursor: pointer;
            user-select: none;
            box-shadow: 0 6px 0 #051a30, 0 10px 15px rgba(0,255,255,0.2); 
            transition: transform 0.1s, box-shadow 0.1s;
        }
        .btn:active {
            transform: translateY(6px);
            box-shadow: 0 0px 0 #051a30, 0 2px 2px rgba(0,255,255,0.2);
            background: linear-gradient(to bottom, #0f3460, #1a1a2e);
        }
        .btn-rotate { 
            background: linear-gradient(to bottom, #e94560, #a02040); 
            border-color: #ffb3c6;
            color: #fff;
            box-shadow: 0 6px 0 #501020, 0 10px 15px rgba(233,69,96,0.4);
        }
        .btn-rotate:active {
            box-shadow: 0 0px 0 #501020, 0 2px 2px rgba(233,69,96,0.4);
            background: linear-gradient(to bottom, #d03050, #801030);
        }
        .cost-info { color: #00ffff; font-size: 13px; text-align: center; margin-top: 15px; text-shadow: 0 0 5px #00ffff;}
        .cost-highlight { color: #ff0055; font-weight: bold; }

        /* --- èƒ½é‡æ¡ --- */
        .energy-container {
            width: 100%;
            background: rgba(15, 52, 96, 0.3);
            padding: 8px;
            border-radius: 8px;
            border: 1px solid #0f3460;
            box-sizing: border-box;
            text-align: center;
        }
        .progress-bar {
            width: 100%;
            height: 18px;
            background: #000;
            border-radius: 10px;
            border: 1px inset #555;
            overflow: hidden;
            margin-top: 5px;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0055, #00ffff, #00ff00);
            width: 0%;
            transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 0 10px rgba(0,255,255,0.8);
        }

        /* --- å…¨å±è€è™æœºå¼¹çª— --- */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0, 5, 20, 0.95);
            display: none; 
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .modal-content {
            background: linear-gradient(45deg, #1a0033, #001a33);
            border: 4px solid #00ffff;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 0 60px rgba(0, 255, 255, 0.5), inset 0 0 30px #e94560;
            animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            width: 80%;
            max-width: 320px;
        }
        @keyframes popIn { from { transform: scale(0.3) rotate(-10deg); opacity: 0; } to { transform: scale(1) rotate(0); opacity: 1; } }
        
        .slot-grid-3x3 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 70px);
            gap: 12px;
            background: #050510;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border: 2px solid #0f3460;
        }
        .slot-cell {
            background: linear-gradient(135deg, #111, #333);
            font-size: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            box-shadow: inset 0 0 20px #000;
            text-shadow: 0 0 15px rgba(255,255,255,0.5);
            border: 1px solid #555;
        }
        .win-line { 
            animation: flashSlot 0.15s infinite alternate; 
            background: linear-gradient(135deg, #ffff00, #ff8800);
            box-shadow: 0 0 30px #FFD700, inset 0 0 15px #fff;
            border-color: #fff;
        }
        @keyframes flashSlot { from { transform: scale(1); } to { transform: scale(1.08); } }
        
        #modal-title { color: #00ffff; font-size: 26px; margin: 0; text-shadow: 0 0 15px #00ffff; letter-spacing: 2px; }
        #modal-message { font-size: 18px; color: #ff00ff; margin-top: 10px; min-height: 48px; font-weight: bold; text-shadow: 0 0 10px #ff00ff;}

    </style>
</head>
<body>

    <h2>ğŸ° é«˜æ€»å®šåˆ¶æŠ•å¸æœº ğŸ°</h2>
    
    <div class="header-panel">
        <div class="asset-info">
            ğŸ’° èµ„äº§: <span id="coin-count">20000</span>
        </div>
        <div style="display: flex; flex-direction: column; align-items: center;">
            <span style="font-size: 10px; color: #00ffff;">NEXT</span>
            <div class="next-piece-box">
                <div id="next-c1" class="cell capsule-left"></div>
                <div id="next-c2" class="cell capsule-right"></div>
            </div>
        </div>
    </div>

    <div class="main-container">
        <div class="game-frame">
            <div id="game-board"></div>
        </div>

        <div style="width: 100%;">
            <div class="touch-controls">
                <button class="btn" onclick="playerMove(0, -1)">â¬…ï¸ å‘å·¦</button>
                <button class="btn" onclick="playerMove(0, 1)">â¡ï¸ å‘å³</button>
                <button class="btn" onclick="hardDrop()" style="color: #ffaa00; border-color: #ffaa00;">â¬‡ï¸ ç¬é™åˆ°åº•</button>
                <button class="btn btn-rotate" onclick="rotatePiece()">ğŸ”„ æ—‹è½¬</button>
            </div>
            <div class="cost-info">ç¬é™ <span style="color:#00ff00">+1å¸</span> | æ—‹è½¬å•æ¬¡ <span class="cost-highlight">-20 å¸</span></div>
        </div>

        <div class="energy-container">
            <div style="font-size: 12px; color: #e94560; font-weight: bold;">âš ï¸ å•æ¬¡æ¶ˆé™¤ 5 ä¸ªä»¥ä¸Šï¼Œæ— è§†èƒ½é‡ç›´æ¥çˆ†æœºï¼ âš ï¸</div>
            <div class="progress-bar">
                <div class="progress-fill" id="energy-bar"></div>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="slot-modal">
        <div class="modal-content">
            <h3 id="modal-title">ğŸ° JACKPOT ğŸ°</h3>
            <div class="slot-grid-3x3" id="slotGrid">
                <div class="slot-cell">ğŸ’</div><div class="slot-cell">ğŸ‹</div><div class="slot-cell">ğŸ””</div>
                <div class="slot-cell">ğŸ’</div><div class="slot-cell">7ï¸âƒ£</div><div class="slot-cell">ğŸ‰</div>
                <div class="slot-cell">ğŸ‹</div><div class="slot-cell">ğŸ’</div><div class="slot-cell">ğŸ’</div>
            </div>
            <div id="modal-message">SYSTEM OVERRIDE...</div>
        </div>
    </div>

<script>
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    
    // --- éŸ³æ•ˆåº“ ---
    function playSound(freq, type, duration, vol=0.1) {
        if(audioCtx.state === 'suspended') return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type; osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(vol, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(); osc.stop(audioCtx.currentTime + duration);
    }
    const s_move = () => playSound(300, 'sine', 0.1, 0.05);
    const s_rotate = () => playSound(600, 'square', 0.1, 0.05);
    const s_land = () => playSound(150, 'triangle', 0.15, 0.1);
    
    const s_hard_drop_cool = () => {
        if ('speechSynthesis' in window) {
            let msg = new SpeechSynthesisUtterance('cool');
            msg.lang = 'en-US';
            msg.pitch = 0.5; 
            msg.rate = 1.5;  
            window.speechSynthesis.speak(msg);
        }
        playSound(200, 'sawtooth', 0.1, 0.2); 
        playSound(100, 'square', 0.2, 0.3);
    };

    const s_clear = () => { playSound(800, 'sawtooth', 0.15); setTimeout(()=>playSound(1200,'square',0.2),80); };
    const s_jackpot = () => { for(let i=0;i<25;i++) setTimeout(()=>playSound(600+i*80,'square',0.1, 0.2), i*50); };
    const s_fail = () => playSound(100, 'sawtooth', 0.6, 0.2);
    const s_prop = () => { playSound(1000, 'sine', 0.3); setTimeout(()=>playSound(1500, 'sine', 0.4), 150); };

    // --- æ ¸å¿ƒï¼šç”µéŸ³ BGM å¼•æ“ (é‡æ„ä¸ºé«˜ç²¾åº¦è°ƒåº¦å™¨ï¼Œé˜²æ­¢æ‰‹æœºç«¯å¡é¡¿æ–­éŸ³) ---
    let bgmStarted = false;
    let nextNoteTime = 0;
    let step = 0;
    const notes = [220, 261.63, 329.63, 440, 329.63, 261.63, 196, 220]; 

    function playBGMStep(time) {
        if (isSpinning) return; 
        // ç”µå­åº•é¼“ (Kick)
        if (step % 4 === 0) {
            let kick = audioCtx.createOscillator(); let kEnv = audioCtx.createGain();
            kick.frequency.setValueAtTime(120, time); kick.frequency.exponentialRampToValueAtTime(0.01, time + 0.1);
            kEnv.gain.setValueAtTime(0.3, time); kEnv.gain.exponentialRampToValueAtTime(0.01, time + 0.1);
            kick.connect(kEnv); kEnv.connect(audioCtx.destination); kick.start(time); kick.stop(time + 0.1);
        }
        // èµ›åšåˆæˆå™¨ (Synth)
        let synth = audioCtx.createOscillator(); let sEnv = audioCtx.createGain();
        synth.type = 'sawtooth'; synth.frequency.setValueAtTime(notes[step % notes.length], time);
        let filter = audioCtx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.setValueAtTime(800 + Math.sin(step)*400, time);
        sEnv.gain.setValueAtTime(0.08, time); sEnv.gain.exponentialRampToValueAtTime(0.01, time + 0.15);
        synth.connect(filter); filter.connect(sEnv); sEnv.connect(audioCtx.destination);
        synth.start(time); synth.stop(time + 0.15);
        step++;
    }

    function bgmScheduler() {
        // æå‰é¢„æ’0.1ç§’çš„éŸ³é¢‘ï¼Œä¿è¯æ‰‹æœºç«¯ç»å¯¹ä¸å¡é¡¿
        while (nextNoteTime < audioCtx.currentTime + 0.1) {
            playBGMStep(nextNoteTime);
            nextNoteTime += 0.13; // 130ms æå¿«BPM
        }
        setTimeout(bgmScheduler, 25);
    }

    function initBGM() {
        if (bgmStarted) return;
        bgmStarted = true;
        nextNoteTime = audioCtx.currentTime + 0.1;
        bgmScheduler();
    }

    // --- å¼ºåˆ¶å”¤é†’ iOS/Chrome éŸ³é¢‘æ ¸å¿ƒ ---
    let audioUnlocked = false;
    function unlockAudio() {
        if (audioUnlocked) return;
        if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
        // æ’­æ”¾ä¸€ç«¯é™éŸ³ç¼“å†²åŒºæ¥å½»åº•è§£é”æ‰‹æœºç«¯éŸ³é¢‘æƒé™
        const buffer = audioCtx.createBuffer(1, 1, 22050);
        const source = audioCtx.createBufferSource();
        source.buffer = buffer;
        source.connect(audioCtx.destination);
        source.start(0);
        
        audioUnlocked = true;
        initBGM();
        // è§£é”åç§»é™¤ç›‘å¬
        ['click', 'touchstart', 'keydown'].forEach(evt => {
            document.removeEventListener(evt, unlockAudio);
        });
    }
    // ç›‘å¬æ‰€æœ‰å¯èƒ½çš„æ“ä½œæ¥å”¤é†’éŸ³ä¹
    ['click', 'touchstart', 'keydown'].forEach(evt => {
        document.addEventListener(evt, unlockAudio, { once: true });
    });


    // --- æ¸¸æˆå˜é‡ ---
    let coins = 20000; 
    const COST_PER_ROTATE = 20; 
    let spinCount = 0;
    let isSpinning = false;
    let eliminations = 0; 
    const ELIMINATION_TARGET = 6; 
    const SYMBOLS = ['ğŸ’', 'ğŸ‹', 'ğŸ‰', 'ğŸ””', 'ğŸ’', '7ï¸âƒ£'];
    const coinDisplay = document.getElementById('coin-count');
    const energyBar = document.getElementById('energy-bar');
    const modal = document.getElementById('slot-modal');
    
    let gameSpeed = 800; 

    let nextColors = { c1: Math.floor(Math.random()*3)+1, c2: Math.floor(Math.random()*3)+1 };

    function deductCoins(amount) {
        if (amount === 0) return true;
        if (coins >= amount) {
            coins -= amount; coinDisplay.innerText = coins;
            return true;
        }
        return false;
    }

    // --- æ¸¸æˆç½‘æ ¼é€»è¾‘ ---
    const ROWS = 16, COLS = 10;
    let board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
    let isVirus = Array(ROWS).fill().map(() => Array(COLS).fill(false));
    const boardEl = document.getElementById('game-board');
    let currentPiece = null;
    let gameInterval = null;
    let isGameOver = false;

    function initGame() {
        boardEl.innerHTML = '';
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                let cell = document.createElement('div');
                cell.classList.add('cell'); cell.id = `cell-${r}-${c}`;
                boardEl.appendChild(cell);
                if (r > 7 && Math.random() < 0.12) { 
                    board[r][c] = Math.floor(Math.random() * 3) + 1;
                    isVirus[r][c] = true;
                }
            }
        }
        updateNextPreview(); spawnPiece();
        gameInterval = setInterval(gameLoop, gameSpeed);
    }

    function drawBoard() {
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                const cell = document.getElementById(`cell-${r}-${c}`);
                cell.className = 'cell';
                let color = board[r][c];
                if(color > 0) {
                    cell.classList.add('c' + color);
                    if(isVirus[r][c]) cell.classList.add('virus');
                    if(!isVirus[r][c]) cell.style.borderRadius = "50%"; 
                } else {
                    cell.style.borderRadius = "0";
                }
            }
        }
        if(currentPiece) drawPiece();
    }

    function drawPiece() {
        let {r, c, c1, c2, rot} = currentPiece;
        let p1 = {r:r, c:c}, p2 = {r:r, c:c};
        let cl1, cl2;
        if(rot === 0) { p2.c = c+1; cl1 = 'capsule-left'; cl2 = 'capsule-right'; }       
        else if(rot === 1) { p2.r = r+1; cl1 = 'capsule-top'; cl2 = 'capsule-bottom'; }   
        else if(rot === 2) { p2.c = c+1; cl1 = 'capsule-left'; cl2 = 'capsule-right'; }   
        else if(rot === 3) { p2.r = r+1; cl1 = 'capsule-top'; cl2 = 'capsule-bottom'; }   
        let col1 = (rot === 0 || rot === 1) ? c1 : c2;
        let col2 = (rot === 0 || rot === 1) ? c2 : c1;

        const cell1 = document.getElementById(`cell-${p1.r}-${p1.c}`);
        if(cell1) { cell1.classList.add('c'+col1); cell1.classList.add(cl1); cell1.style.borderRadius="";}
        const cell2 = document.getElementById(`cell-${p2.r}-${p2.c}`);
        if(cell2) { cell2.classList.add('c'+col2); cell2.classList.add(cl2); cell2.style.borderRadius="";}
    }

    function updateNextPreview() {
        document.getElementById('next-c1').className = `cell capsule-left c${nextColors.c1}`;
        document.getElementById('next-c2').className = `cell capsule-right c${nextColors.c2}`;
    }

    function spawnPiece() {
        currentPiece = { r: 0, c: 4, c1: nextColors.c1, c2: nextColors.c2, rot: 0 };
        nextColors = { c1: Math.floor(Math.random()*3)+1, c2: Math.floor(Math.random()*3)+1 };
        updateNextPreview();
        if(!isValid(0, 4) || !isValid(0, 5)) gameOver();
        drawBoard();
    }

    function isValid(r, c) { return r >= 0 && r < ROWS && c >= 0 && c < COLS && board[r][c] === 0; }

    function gameLoop() {
        if(isGameOver || isSpinning || !currentPiece) return;
        if(!movePiece(1, 0)) lockPiece();
    }

    function playerMove(dr, dc) {
        if(isGameOver || isSpinning || !currentPiece) return;
        s_move();
        movePiece(dr, dc);
    }

    function movePiece(dr, dc) {
        let {r, c, rot} = currentPiece;
        let nr = r + dr, nc = c + dc;
        let nr2 = nr + (rot % 2 === 0 ? 0 : 1); let nc2 = nc + (rot % 2 === 0 ? 1 : 0);
        if(isValid(nr, nc) && isValid(nr2, nc2)) {
            currentPiece.r = nr; currentPiece.c = nc; drawBoard(); return true;
        }
        return false;
    }

    function hardDrop() {
        if(isGameOver || isSpinning || !currentPiece) return;
        let dropped = false;
        while(movePiece(1, 0)) { dropped = true; }
        if(dropped) {
            coins += 1;
            coinDisplay.innerText = coins;
            s_hard_drop_cool(); 
        }
        lockPiece(); 
    }

    function rotatePiece() {
        if(isGameOver || isSpinning || !currentPiece) return;
        if(!deductCoins(COST_PER_ROTATE)) return; 
        let {r, c, rot} = currentPiece; let nextRot = (rot + 1) % 4; let isValidMove = false;
        if (nextRot % 2 === 0) {
            if (isValid(r, c+1)) isValidMove = true;
            else if (isValid(r, c-1) && isValid(r, c)) { c = c-1; isValidMove = true; }
        } else {
            if (isValid(r+1, c)) isValidMove = true;
        }
        if(isValidMove) {
            currentPiece.rot = nextRot; currentPiece.c = c; s_rotate(); drawBoard();
        }
    }

    function lockPiece() {
        let {r, c, c1, c2, rot} = currentPiece;
        let r2 = r + (rot % 2 === 0 ? 0 : 1); let c2_pos = c + (rot % 2 === 0 ? 1 : 0);
        board[r][c] = (rot === 0 || rot === 1) ? c1 : c2;
        board[r2][c2_pos] = (rot === 0 || rot === 1) ? c2 : c1;
        s_land(); currentPiece = null; drawBoard(); checkClear(); 
    }

    function applyGravity() {
        let moved = false;
        for(let c=0; c<COLS; c++) {
            for(let r=ROWS-1; r>=0; r--) {
                if(board[r][c] === 0) {
                    for(let nr=r-1; nr>=0; nr--) {
                        if(board[nr][c] !== 0 && !isVirus[nr][c]) {
                            board[r][c] = board[nr][c]; board[nr][c] = 0;
                            moved = true; break;
                        }
                    }
                }
            }
        }
        return moved;
    }

    function checkClear() {
        let toClear = new Set();
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<=COLS-4; c++) {
                let col = board[r][c]; if(col === 0) continue;
                if(board[r][c+1]===col && board[r][c+2]===col && board[r][c+3]===col) 
                    for(let i=0; i<4; i++) toClear.add(`${r},${c+i}`);
            }
        }
        for(let c=0; c<COLS; c++) {
            for(let r=0; r<=ROWS-4; r++) {
                let col = board[r][c]; if(col === 0) continue;
                if(board[r+1][c]===col && board[r+2][c]===col && board[r+3][c]===col) 
                    for(let i=0; i<4; i++) toClear.add(`${r+i},${c}`);
            }
        }

        if(toClear.size > 0) {
            s_clear();
            let clearCount = toClear.size;
            toClear.forEach(key => {
                let [r, c] = key.split(',').map(Number);
                board[r][c] = 0; isVirus[r][c] = false;
            });
            
            applyGravity();
            drawBoard();

            if (clearCount >= 5) {
                setTimeout(() => startSlotMachineModal(true), 300);
            } else {
                eliminations++; updateEnergyBar();
                if (eliminations >= ELIMINATION_TARGET) {
                    setTimeout(() => startSlotMachineModal(false), 300);
                } else {
                    setTimeout(checkClear, 400); 
                }
            }
        } else {
             if(!isSpinning && !currentPiece) spawnPiece();
        }
    }

    function updateEnergyBar() {
        let pct = (eliminations / ELIMINATION_TARGET) * 100;
        energyBar.style.width = Math.min(pct, 100) + '%';
    }

    function gameOver() {
        isGameOver = true; clearInterval(gameInterval);
        alert("GAME OVER! é«˜æ€»æŠ•å¸æœºå·²æ¸…ç›˜ï¼");
    }

    // --- é«˜æ€»ä¸“å±ï¼šåˆ†çº§æƒ©ç½šé£æ§ç³»ç»Ÿ ---
    function getRandomProp() {
        const props = ['speed_up', 'drop_3', 'shuffle', 'add_row', 'crazy_drop_1s', 'crazy_drop_2s', 'crazy_drop_3s'];
        return props[Math.floor(Math.random() * props.length)];
    }

    function getRiggedOutcome(isSuperTrigger) {
        spinCount++;
        if (coins > 28000) return { win: false, row: -1, symbol: '', prop: getRandomProp() }; 
        if (spinCount === 1) return { win: true, row: 1, symbol: '7ï¸âƒ£', prop: null }; 
        
        let winRate = isSuperTrigger ? 0.3 : 0.12;
        if (Math.random() < winRate) {
            return { win: true, row: Math.floor(Math.random()*3), symbol: SYMBOLS[Math.floor(Math.random()*3)], prop: null };
        }
        
        let prop = Math.random() < 0.6 ? getRandomProp() : null;
        return { win: false, row: -1, symbol: '', prop: prop };
    }

    function executeDrop3() {
        for(let i=0; i<6; i++) {
            let c = Math.floor(Math.random() * COLS);
            let color = Math.floor(Math.random() * 3) + 1;
            let placed = false;
            for(let r=0; r<ROWS; r++) {
                if (board[r][c] !== 0) {
                    if (r > 0) { board[r-1][c] = color; isVirus[r-1][c] = false; placed = true; }
                    break;
                }
            }
            if (!placed) { board[ROWS-1][c] = color; isVirus[ROWS-1][c] = false; }
        }
        applyGravity();
    }

    function executeShuffle() {
        let blocks = [];
        for(let r=0; r<ROWS; r++){
            for(let c=0; c<COLS; c++){
                if(board[r][c] > 0) {
                    blocks.push({col: board[r][c], vir: isVirus[r][c]});
                    board[r][c] = 0; isVirus[r][c] = false;
                }
            }
        }
        blocks.sort(() => Math.random() - 0.5);
        let bIdx = 0;
        for (let r = ROWS - 1; r >= 0 && bIdx < blocks.length; r--) {
            let randomCols = [0,1,2,3,4,5,6,7,8,9].sort(() => Math.random() - 0.5);
            for(let c of randomCols) {
                if (bIdx < blocks.length) {
                    board[r][c] = blocks[bIdx].col;
                    isVirus[r][c] = blocks[bIdx].vir;
                    bIdx++;
                }
            }
        }
        applyGravity();
    }

    function executeAddRow() {
        for(let c=0; c<COLS; c++) {
            if(board[0][c] !== 0 || board[1][c] !== 0) {
                gameOver(); return;
            }
        }
        for(let r=1; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                board[r-1][c] = board[r][c];
                isVirus[r-1][c] = isVirus[r][c];
            }
        }
        for(let c=0; c<COLS; c++) {
            board[ROWS-1][c] = Math.floor(Math.random() * 3) + 1;
            isVirus[ROWS-1][c] = false;
        }
        applyGravity();
    }

    function executeCrazyDrop(duration) {
        if(!currentPiece && !isGameOver) spawnPiece();
        clearInterval(gameInterval);
        
        gameInterval = setInterval(gameLoop, 80); 
        
        setTimeout(() => {
            if(!isGameOver) {
                clearInterval(gameInterval);
                if (!isSpinning) {
                    gameInterval = setInterval(gameLoop, gameSpeed);
                }
            }
        }, duration);
    }

    function startSlotMachineModal(isSuperTrigger) {
        if (isSpinning) return;
        isSpinning = true;
        clearInterval(gameInterval); 
        
        if (!isSuperTrigger) { eliminations = 0; updateEnergyBar(); }
        modal.style.display = 'flex';
        
        if (isSuperTrigger) {
            document.getElementById('modal-message').innerHTML = "ğŸ”¥ 5è¿ç¥æ“ä½œï¼<br>è¶…çº§çˆ†æœºï¼ ğŸ”¥";
            document.getElementById('modal-message').style.color = "#ff0000";
        } else {
            document.getElementById('modal-message').innerText = "ğŸ° èƒ½é‡çˆ†å‘ï¼æ‘‡å¥–ä¸­... ğŸ°";
            document.getElementById('modal-message').style.color = "#00ffff";
        }
        
        let cells = modal.querySelectorAll('.slot-cell');
        cells.forEach(c => c.classList.remove('win-line'));
        
        let spinSoundTimer = setInterval(() => playSound(Math.random()*800+400, 'square', 0.05), 40);
        let scrollTimer = setInterval(() => {
            cells.forEach(c => c.innerText = SYMBOLS[Math.floor(Math.random() * SYMBOLS.length)]);
        }, 50);

        setTimeout(() => {
            clearInterval(scrollTimer); clearInterval(spinSoundTimer);
            const outcome = getRiggedOutcome(isSuperTrigger);
            let finalGrid = [];
            
            for (let r = 0; r < 3; r++) {
                if (outcome.win && outcome.row === r) {
                    finalGrid.push(outcome.symbol, outcome.symbol, outcome.symbol);
                } else {
                    let row = [SYMBOLS[Math.floor(Math.random()*SYMBOLS.length)], SYMBOLS[Math.floor(Math.random()*SYMBOLS.length)], SYMBOLS[Math.floor(Math.random()*SYMBOLS.length)]];
                    if(row[0]===row[1] && row[1]===row[2]) row[2] = SYMBOLS[(SYMBOLS.indexOf(row[2])+1)%SYMBOLS.length]; 
                    finalGrid.push(...row);
                }
            }
            cells.forEach((c, i) => c.innerText = finalGrid[i]);

            if (outcome.win) {
                let prize = outcome.symbol === '7ï¸âƒ£' ? 3000 : 800;
                if(isSuperTrigger) prize = Math.floor(prize * 1.2); 
                
                coins += prize; coinDisplay.innerText = coins; s_jackpot();
                document.getElementById('modal-message').innerHTML = `ğŸ‰ ç‹‚æš´çˆ†æœºï¼<br>è·å¾— ${prize} å¸ï¼ ğŸ‰`;
                document.getElementById('modal-message').style.color = "#00ff00";
                
                let startIndex = outcome.row * 3;
                cells[startIndex].classList.add('win-line');
                cells[startIndex+1].classList.add('win-line');
                cells[startIndex+2].classList.add('win-line');
            } else {
                if (outcome.prop) {
                    s_prop();
                    if (outcome.prop === 'speed_up') {
                        gameSpeed = Math.max(200, gameSpeed - 100);
                        document.getElementById('modal-message').innerHTML = `âš¡ æœºå™¨æš´èµ° âš¡<br>ä¸‹è½é€Ÿåº¦æ°¸ä¹…å¢åŠ ï¼`;
                        document.getElementById('modal-message').style.color = "#ff8800";
                    } else if (outcome.prop === 'drop_3') {
                        executeDrop3(); drawBoard();
                        document.getElementById('modal-message').innerHTML = "âš ï¸ æƒ©ç½šï¼šå¤©é™å±æœº âš ï¸<br>å¼ºè¡Œç ¸ä¸‹ 3 ä¸ªèƒ¶å›Šï¼";
                        document.getElementById('modal-message').style.color = "#ff4400";
                    } else if (outcome.prop === 'shuffle') {
                        executeShuffle(); drawBoard();
                        document.getElementById('modal-message').innerHTML = "ğŸŒ€ ç©ºé—´æ‰­æ›² ğŸŒ€<br>æ‰€æœ‰èƒ¶å›Šé‡æ–°æ’åˆ—ï¼";
                        document.getElementById('modal-message').style.color = "#ff00ff";
                    } else if (outcome.prop === 'add_row') {
                        executeAddRow(); drawBoard();
                        document.getElementById('modal-message').innerHTML = "ğŸ’€ æƒ©ç½šï¼šåº•ç›˜æŠ¬å‡ ğŸ’€<br>åº•éƒ¨å¢åŠ ä¸€è¡Œéšœç¢ï¼";
                        document.getElementById('modal-message').style.color = "#ff0000";
                    } else if (outcome.prop.startsWith('crazy_drop')) {
                        let seconds = outcome.prop === 'crazy_drop_1s' ? 1 : (outcome.prop === 'crazy_drop_2s' ? 2 : 3);
                        document.getElementById('modal-message').innerHTML = `ğŸŒªï¸ æƒ©ç½šï¼šç–¯ç‹‚æ¨¡å¼ ğŸŒªï¸<br>åœ°å¿ƒå¼•åŠ›æš´å¢ ${seconds} ç§’ï¼`;
                        document.getElementById('modal-message').style.color = "#ff0000";
                    }
                } else {
                    s_fail();
                    document.getElementById('modal-message').innerText = "ğŸ’¦ å•¥éƒ½æ²¡ä¸­ï¼ç»§ç»­åŠªåŠ›ï¼";
                    document.getElementById('modal-message').style.color = "#aaa";
                }
            }

            setTimeout(() => {
                modal.style.display = 'none';
                isSpinning = false;
                cells.forEach(c => c.classList.remove('win-line'));
                
                if (outcome && outcome.prop && outcome.prop.startsWith('crazy_drop')) {
                    let duration = outcome.prop === 'crazy_drop_1s' ? 1000 : (outcome.prop === 'crazy_drop_2s' ? 2000 : 3000);
                    executeCrazyDrop(duration);
                    if(!currentPiece && !isGameOver) checkClear();
                } else {
                    if(!currentPiece && !isGameOver) {
                        checkClear(); 
                    }
                    gameInterval = setInterval(gameLoop, gameSpeed);
                }
            }, 2500);

        }, 1500);
    }

    // é”®ç›˜æ”¯æŒ
    document.addEventListener('keydown', (e) => {
        if(isSpinning) return;
        switch(e.key) {
            case 'ArrowLeft': playerMove(0, -1); break;
            case 'ArrowRight': playerMove(0, 1); break;
            case 'ArrowDown': hardDrop(); break; 
            case 'ArrowUp': rotatePiece(); break;
        }
    });

    initGame();

</script>
</body>
</html>